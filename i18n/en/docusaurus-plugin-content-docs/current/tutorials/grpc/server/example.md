---
title: Service Example
slug: /docs/tutorials/grpc/server/example
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Overview

go-zero provides a gRPC server that provides：

1. Service discovery capability (etcd as registration centre)
2. Load Balancer(p2c algorithms)
3. Node Affinity
4. Multi-node direct connection mode
5. Timeout processing
6. Traffic limiting, breaking
7. Authentication capacity
8. Exception Capture

## Examples

In go-zero, we can use goctl to quickly sound a gRPC service or create an example of a gRPC service using the goctl 0 code.

:::tip Tips
Quickly generate and start a goctl service example for a gRPC service that can be referenced <a href="/docs/tutorials/cli/quickstart" target="_blank">Quick Start Microservice Book</a>
:::

We're here to create a full gRPC service with a proto.

### 1. Create a service directory and initialize the go module project

```shell
$ mkdir demo && cd demo
$ go mod init demo
```

### 2. Quickly generate a proto file

```protobuf
$ goctl rpc -o greet.proto
```

### 3. Proto generate gRPC services

```shell
$ goctl rpc protoc greet.proto --go_out=.  --go-grpc_out=.  --zrpc_out=.
```

::tip Tips

1. goctl installation please refer to <a href="/docs/tasks/installation/goctl" target="_blank">Goctl Installation</a>
1. rpc code generation command tutorial reference <a href="/docs/tutorials/cli/rpc" target="_blank">goctl rpc</a>
1. Proto use related questions refer to <a href="/docs/tutorials/proto/faq" target="_blank">Proto Code Generating FAQ</a>
:::

### 4. Layout

```text
demo
├── etc
│   └── greet.yaml
├── go.mod
├── greet
│   ├── greet.pb.go
│   └── greet_grpc.pb.go
├── greet.go
├── greet.proto
├── greetclient
│   └── greet.go
└── internal
    ├── config
    │   └── config.go
    ├── logic
    │   └── pinglogic.go
    ├── server
    │   └── greetserver.go
    └── svc
        └── servicecontext.go

8 directories, 11 files

```

:::tip hint
service directory structure introduction refer to <a href="/docs/concepts/layout" target="_blank">Project Structure</a>
:::

### 5. Discovery/direct service mode

In go-zero we support the etcd service registration and direct connection mode and we only adjust the static configuration files in the etc directory.

:::tip hint
gRPC service configuration accessible <a href="/docs/tutorials/grpc/server/configuration" target="_blank">GRPC Service Configuration </a>

In addition to a go-zero built-in ecd as a service, the community also provides support for the discovery of services such as nacos, consul, etc. More Services found components <a href="https://github.com/zeromicro/zero-contrib/tree/main/zrpc/registry" target="_blank">for details</a>
:::

<Tabs>

<TabItem value="etcd 服务注册" label="etcd 服务注册" default>

To use <a href="https://etcd.io/" target="_blank">etcd</a> as a registry, simply add the etcd configuration to the static configuration file, with the following minimal reference configuration (gray underlined section):

```yaml title=demo/etc/greet.yaml {3-6}
Name: greet.rpc
ListenOn: 0.0.0.0:8080
Etcd:
  Hosts:
  - 127.0.0.1:2379
  Key: greet.rpc
```

The service is registered with the key greet.rpc, which we can see in etcd by the following method:

```shell
$ etcdctl get --prefix greet.rpc
greet.rpc/7587870460981677828
192.168.72.53:8080
```

Since the key registered by etcd is `greet.rpc`, from the business presentation layer, it is a key registered to etcd, but go-zero is actually storing the key with an etcd
The go-zero layer is actually storing the key with a tenant id of etcd, so during service discovery, it will also fetch all available ip nodes with the `etcdctl get --prefix` command.

</TabItem>

<TabItem value="直连模式" label="直连模式" default>

By contrast, using direct link mode removes the etcd configuration, go-zero auto-identification, with a minimum configuration reference：

```yaml title=demo/etc/greet.yaml {3-6}
Name: greet.rpc
ListenOn: 0.0.0.0:8080
```

</TabItem>

</Tabs>

### Stubi implementation

The code generated by goctl does not require the user to implement the stub. The goctl tool will help you to implement all of this, referencing the following:

```go title=demo/internal/server/greetserver.go
// Code generated by goctl. DO NOT EDIT.
// Source: greet.proto

package server

import (
    "context"

    "demo/greet"
    "demo/internal/logic"
    "demo/internal/svc"
)

type GreetServer struct {
    svcCtx *svc.ServiceContext
    greet.UnimplementedGreetServer
}

func NewGreetServer(svcCtx *svc.ServiceContext) *GreetServer {
    return &GreetServer{
        svcCtx: svcCtx,
    }
}

func (s *GreetServer) Ping(ctx context.Context, in *greet.Request) (*greet.Response, error) {
    l := logic.NewPingLogic(ctx, s.svcCtx)
    return l.Ping(in)
}

```

### Writing business code

Once the code is generated with goctl, we simply need to fill in our business code in the log file, reference business code (grey bottom texture part)：

```go title=demo/internal/logic/pinglogic.go {28}
package logic

import (
    "context"

    "demo/greet"
    "demo/internal/svc"

    "github.com/zeromicro/go-zero/core/logx"
)

type PingLogic struct {
    ctx    context.Context
    svcCtx *svc.ServiceContext
    logx.Logger
}

func NewPingLogic(ctx context.Context, svcCtx *svc.ServiceContext) *PingLogic {
    return &PingLogic{
        ctx:    ctx,
        svcCtx: svcCtx,
        Logger: logx.WithContext(ctx),
    }
}

func (l *PingLogic) Ping(in *greet.Request) (*greet.Response, error) {
    return &greet.Response{
        Pong: "pong",
    }, nil
}

```

### 8. Enable gRPC debug switch

gRPC provides debugging capabilities so that we can debug with tools like <a href="https://github.com/fullstorydev/grpcurl" target="_blank">grpcurl</a>， In go-zero, it is recommended to turn it on in development and test environments, and off in pre-production and official environments，So we configure the environment mode in the static configuration file as `dev` or `test` (default is dev environment), the relevant code is as follows:

<Tabs>

<TabItem value="demo/greet.go" label="demo/greet.go" default>

```go {13-15}
package main
...
func main() {
    flag.Parse()

    var c config.Config
    conf.MustLoad(*configFile, &c)
    ctx := svc.NewServiceContext(c)

    s := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) {
        greet.RegisterGreetServer(grpcServer, server.NewGreetServer(ctx))

        if c.Mode == service.DevMode || c.Mode == service.TestMode {
            reflection.Register(grpcServer)
        }
    })
    ...
}

```

</TabItem>

<TabItem value="demo/etc/greet.yaml" label="demo/etc/greet.yaml" default>

```yaml {3}
Name: greet.rpc
ListenOn: 0.0.0.0:8080
Mode: dev
Etcd:
  Hosts:
  - 127.0.0.1:2379
  Key: greet.rpc

```

</TabItem>

</Tabs>

### 9. Middleware Usage

#### Built Middleware

go-zero rpc is embedded in a very rich intermediary, see<a href="https://github.com/zeromicro/go-zero/tree/master/zrpc/internal/serverinterceptors" target="_blank">serverinterceptors</a>

- StreamAuthorizeInterceptor|UnaryAuthorizeInterceptor
- StreamBreakerInterceptor|UnaryBreakerInterceptor
- UnaryPrometheusInterceptor
- StreamRecoverInterceptor|UnaryRecoverInterceptor
- UnarySheddingInterceptor
- UnaryStatInterceptor
- UnaryTimeoutInterceptor
- StreamTraceInterceptor|UnaryTraceInterceptor

In the above built-in intermediates, link tracking intermediates, indicator statistical intermediary, time statistical intermediary, abnormal capture medium, melting intermediation can be configured to turn on or off and other intermediates will be enabled by default. Specific configuration can be consulted<a href="/docs/tutorials/grpc/server/configuration" target="_blank">service configuration</a>

#### Custom Middleware

```go {21-22,28-35}
package main
...
var configFile = flag.String("f", "etc/greet.yaml", "the config file")

func main() {
    flag.Parse()

    var c config.Config
    conf.MustLoad(*configFile, &c)
    ctx := svc.NewServiceContext(c)

    s := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) {
        greet.RegisterGreetServer(grpcServer, server.NewGreetServer(ctx))

        if c.Mode == service.DevMode || c.Mode == service.TestMode {
            reflection.Register(grpcServer)
        }
    })
    defer s.Stop()

    s.AddUnaryInterceptors(exampleUnaryInterceptor)
    s.AddStreamInterceptors(exampleStreamInterceptor)

    fmt.Printf("Starting rpc server at %s...\n", c.ListenOn)
    s.Start()
}

func exampleUnaryInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
    // TODO: fill your logic here
    return handler(ctx, req)
}
func exampleStreamInterceptor(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
    // TODO: fill your logic here
    return handler(srv, ss)
}
```

### 10. Metadata transfer

Reference <a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md" target="_blank">Metata</a>
